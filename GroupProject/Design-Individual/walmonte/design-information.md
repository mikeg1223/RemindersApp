## Assignment5: Reminders App Design Information

1. A list consisting of reminders the users want to be aware of. The application must allow users to add reminders to a list, delete reminders from a list, and edit the reminders in the list.	
   - *To meet this requirement, I added the following classes with the corresponding functionalities (add, remove, edit reminders): **User** class, **Reminder** class, and **ReminderList** class.* The reasoning behind this being that these three entities should be capable of executing some action or have some property. For example, a user can have a `name` and `create` a reminder or a reminderList; a reminderList can also have a `name` or `delete` reminders; a reminder can have a `date` and `issue` an alert to the user.
2. The application must contain a database (DB) of reminders and corresponding data.
   - *This requirement does not directly impact the class-level design and therefore can be considered at a later stage of the development process. For now, specifying the Reminder class and its attributes should partially meet this demand.*
3. Users must be able to add reminders to a list by picking them from a hierarchical list, where the first level is the reminder type (e.g., Appointment), and the second level is the name of the actual reminder (e.g., Dentist Appointment).
   - *The **addReminder()** function of the ReminderList class should take the user through the process of choosing a reminder type from an existing list of types or adding a new one, as well as choosing the name of a reminder.*
4. Users must also be able to specify a reminder by typing its name. In this case, the application must look in its DB for reminders with similar names and ask the user whether that is the item they intended to add. If a match (or nearby match) cannot be found, the application must ask the user to select a reminder type for the reminder, or add a new one, and then save the new reminder, together with its type, in the DB.
   - *This is a very specific requirement that requires direct interaction with the UI and the DB, whose detailed implementation is beyond the scope of this class diagram. For now, the function **findReminder()** under the ReminderList class aids the meeting of this demand.*
5. The reminders must be saved automatically and immediately after they are modified.
   - *This is a very specific requirement and can be implemented via the **edit()** method of the Reminder class.*
6. Users must be able to check off reminders in the list (without deleting them).
   - *This requirement is met in the form of a Boolean attribute (**"completed"**) that belongs to the Reminder class. When a reminder is checked it still exists with completed=true.*
7. Users must also be able to clear all the check-off marks in the reminder list at once.
   - *To meet this demand, I have added a **selectAllReminders()** method to the ReminderList class, which makes the **selected** attribute true in all instances of Reminder under a given reminder list and is triggered by a button or another UI element. After such button has been pressed, the user can take another action such as delete or check-off (both methods of the ReminderList class) the selected reminders.*
8. Check-off marks for the reminder list are persistent and must also be saved immediately.
   - *As UI elements, the behavior and functionality of check-off marks can be considered on another stage of the design. In the meantime, the "**completed**" attribute in the Reminder class, which is closely related to the check-off marks, partially addresses this demand.* 
9. The application must present the reminders grouped by type.
   - *I consider this requirement to be out of the scope of the class diagram because it is a feature that can be implemented in development using a key-value pair data structure to map reminderType strings (to) ~> Reminder arrays (or lists) and possibly a sorting function to organize reminders inside an array in alphabetical order. Another option could be a function to organize reminders first by type and then by name. For now, I believe the **reminderType** attribute in the Reminder class is an element that partially addresses this requirement.*
10. The application must support multiple reminder lists at a time (e.g., “Weekly”, “Monthly”, “Kid’s Reminders”). Therefore, the application must provide the users with the ability to create, (re)name, select, and delete reminder lists.
    - *This requirement will be met via the methods **setName(), selectReminderList()** and **deleteReminderList()** of the ReminderList class. Here, I assume that there cannot be overlapping lists, i.e. a reminder cannot belong to two different lists.*
11. The application should have the option to set up reminders with day and time alert. If this option is selected allow option to repeat the behavior.
    - *All reminders have a **dateAndTime** attribute, a date object whose default value is currentDate + 24hrs. The app should have a yes/no button connected to a **repeats** Boolean attribute, and a **repeatSchedule** attribute which together allow the user to set up recurrent reminders. The **setAlert()** method allows the user to set up reminder alerts. All attributes in this paragraph belong to the Reminder class.*
12. Extra Credit: Option to set up reminder based on location.
    - *This feature is implemented in the class diagram via two attributes in the Reminder class: **"withLocation"** (Boolean) and **"location"** (string). The **"withLocation"** option allows the user choose whether to specify a **"location"** related to his/her reminder. The source of the location (user input or current location of the user's device) is beyond the scope of this document.*
13. The User Interface (UI) must be intuitive and responsive.
    - *This requirement is outside of the scope of this class diagram.*